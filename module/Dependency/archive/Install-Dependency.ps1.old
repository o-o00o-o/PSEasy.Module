#Requires -Version 5.0
using namespace System.Collections.Generic

<#
.SYNOPSIS

.EXAMPLE

.DESCRIPTION

.NOTES

#>
function Install-Dependency {
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipeline = $true)]
        [Alias('Context')]
        [PSCustomObject]
        # a Context object from Get-VegaContext
        $InputObject,

        [Parameter(Position = 1, Mandatory)]
        [string[]]
        # Specifies the type of dependency to install
        $Path,

        # [Parameter(Position, Mandatory)]
        # [ValidateSet('Install','Initialise')]
        # [string[]]
        # # Indicates if we should install the dependency or also initialise in the current session (sometimes you want to delay this due to DLL hell)
        # $Run = @('Install'),

        [Parameter(Position)]
        [switch]
        # Indicates if we should install the dependency or also initialise in the current session (sometimes you want to delay this due to DLL hell)
        $Initialise,

        [Parameter()]
        [switch]
        # If set, uses the required by configuration to install all dependencies
        $AllForScript,

        [Parameter(Position = 2)]
        [string]
        # The destination folder to install to (if required)
        $Destination,

        [parameter()]
        [switch]
        # By default we won't install if already installed. Force will first remove then install again
        $Force
    )
    try {
        . "$PSScriptRoot\..\Install-DependencyNuget.ps1"
        . "$PSScriptRoot\..\Install-DependencyPSModule.ps1"
        . "$PSScriptRoot\..\Install-DependencyPSPackageProvider.ps1"
        . "$PSScriptRoot\..\Install-DependencyWebDownload.ps1"
        . "$PSScriptRoot\Install-DependencyFromName.ps1"
        . "$PSScriptRoot\Install-DependencyFromNameAndType.ps1"

        Set-StrictMode -Version 2
        $ErrorActionPreference = "Stop"

        Write-Verbose "START: Loading context"

        # Setup Context if not given
        if (! ($InputObject)) {
            $ContextPath = "$PSScriptRoot\..\application\Get-VegaContext.ps1"
            if (! (Test-Path $ContextPath)) {
                $ContextPath = "$PSScriptRoot\..\..\application\Get-VegaContext.ps1"
            }
            if (! (Test-Path $ContextPath)) {
                throw "Cannot find Get-VegaContext.ps1"
            }

            $Context = & $ContextPath -Environment 'None' 2> $null # we don't need the environment yet. Perhaps we can make context global in the future, but will need testing
        } else {
            $Context = $InputObject
        }
        Write-Verbose "END: Loading context"

        if ($AllForScript.IsPresent) {
            $overallElapsed = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Verbose "START: Installing all Dependencies for $Path"

            $nuGetConfig = [List[PSCustomObject]]::new()
            foreach ($type in $context.GetArray($context.dependencies, @{})) {
                if ($type.Name -ne '_comment') {
                    foreach ($dep in $context.GetArray($type, @{Type = $type.Name })) {
                        if ($dep.scripts -contains $path -and ( # only run for the indicate script
                                # only run if we are running the PS Edition indicated by OnlyPSEdition
                                -not $dep.PSObject.Properties['OnlyPSEdition'] -or (
                                    $dep.PSObject.Properties['OnlyPSEdition'] -and
                                    $PSEdition -eq $dep.OnlyPSEdition
                                )
                            )) {
                            $optionalArgs = @{}

                            if ('destinationOverride' -in $dep.psobject.properties.name) {
                                $optionalArgs.Add('Destination', (Join-Path (Join-Path $context.rootPath $dep.destinationOverride) "Depend-$($type.Name)"))
                            } elseif ($Destination) {
                                $optionalArgs.Add('Destination', (Join-Path $Destination "Depend-$($type.Name)"))
                            }
                            if ($dep.PSObject.Properties['forceImport']) {
                                $optionalArgs.Add('ForceImport', $dep.forceImport)
                            }

                            if ($type.Name -eq 'NuGet') {
                                # we have to do nuget as a block so just record the details for later
                                # TODO pass this on to the Nuget dependency tool and don't do it here.
                                $configItem = [PSCustomObject]@{
                                    id          = $dep.Name
                                    version     = $dep.Version
                                    destination = $optionalArgs['Destination']
                                    ## requires PS 7 which we don't yet have on the build server
                                    #addType = $dep.PSObject.Properties['AddType'] ? $dep.AddType : @()
                                    #copyItemFromPackage = $dep.PSObject.Properties['CopyItemFromPackage'] ? $dep.CopyItemFromPackage : @()
                                }

                                if ($dep.PSObject.Properties['AddType']) {
                                    $configItem | Add-Member 'addType' $dep.AddType
                                } else {
                                    $configItem | Add-Member 'addType' @()
                                }

                                if ($dep.PSObject.Properties['copyItemFromPackage']) {
                                    $configItem | Add-Member 'copyItemFromPackage' $dep.CopyItemFromPackage
                                } else {
                                    $configItem | Add-Member 'copyItemFromPackage' @()
                                }

                                if ($dep.PSObject.Properties['importModule']) {
                                    $configItem | Add-Member 'importModule' $dep.importModule
                                } else {
                                    $configItem | Add-Member 'importModule' @()
                                }
                                $nuGetConfig.Add($configItem)
                            } else {
                                # otherwise install as we go
                                Write-Verbose "START: Installing-DependencyFromNameAndType $($type.Name) $($dep.Name)"
                                Install-DependencyFromNameAndType -Type $type.Name -Name $dep.Name -Dependency $dep @optionalArgs -Force:$Force.IsPresent
                                Write-Verbose "END: Installing-DependencyFromNameAndType $($type.Name) $($dep.Name)"
                            }
                        }
                    }
                }
            }
            $nugetConfig | Format-List | Out-String | Write-Verbose

            # Now install nuget (if we have any)
            if ($nugetConfig.Count -gt 0) {
                # we may have some with different destinations so nuget each group by destination
                foreach ($groupBy in ($nugetConfig | Group-Object -property destination)) {
                    $groupBy | Format-List | Out-String | Write-Verbose
                    $nuGetConfigTemplate = @"
<!-- DO NOT CHANGE THIS: This is autogenerated by Install-Dependency so anything you do here will be undone. Use dependencies.global.json to control what gets installed by which script-->
<packages>$($groupBy.Group | Foreach-Object { [string]::format("`n`t<package id=""{0}"" version=""{1}"" />",$_.id,$_.version)})
</packages>
"@
                    $optionalArgs = @{}
                    if ($groupBy.Name) {
                        $optionalArgs.Add('Destination', $groupBy.Name)
                    }

                    $nuGetConfigFolderName = "VegaNuget$(([IO.Path]::GetFileNameWithoutExtension([IO.Path]::GetRandomFileName())))"
                    $nuGetConfigFolder = "$(Join-Path ($env:TMP) $nuGetConfigFolderName)" # [System.IO.Path]::GetTempFileName()
                    try {
                        $null = New-Item -ItemType Directory $nuGetConfigFolder -Force
                        $nuGetConfigPath = Join-Path $nuGetConfigFolder "packages.config" # Join-Path $optionalArgs["Destination"] "packages.config"
                        Write-Verbose "Generated File: $nuGetConfigPath `n----------------------------`n$nuGetConfigTemplate`n----------------------------"
                        $null = New-Item -ItemType File -Path $nuGetConfigPath -Value $nuGetConfigTemplate -Force
                        Install-DependencyNuget -NugetPath (Join-Path $Destination $context.nugetSubpath) -ConfigPath $nuGetConfigPath @optionalArgs
                    } finally {
                        Remove-Item $nuGetConfigFolder -force -recurse -ErrorAction 'SilentlyContinue' # cleanup, although with whatif this will error so ignore it
                    }
                }

                if ($Initialise) {
                    Write-Verbose 'Initialising Nuget Payload'
                    foreach ($nugetConfigItem in ($nugetConfig | Where-Object { $_.copyItemFromPackage } )) {
                        foreach ($copyItem in $nugetConfigItem.copyItemFromPackage) {
                            $fromPackage = $nugetConfig | Where-Object { $_.id -eq $copyItem.FromPackageName }
                            if (-not $fromPackage) {
                                throw "Can't find package $copyItem.FromPackageName in set of nuget Packages. Ensure that it exists in the dependency config and that it exists for the current PSEdition and same 'script'"
                            }
                            $typeArgs = @{
                                Path        = Join-Path (Join-Path $fromPackage.Destination $fromPackage.id) $copyItem.fromPath
                                Destination = Join-Path (Join-Path $nugetConfigItem.Destination $nugetConfigItem.id) $copyItem.toPath
                                Force       = $true
                                Confirm     = $false
                            }
                            (
                            ('$typeArgs = @{') +
                            ($typeArgs.GetEnumerator() | Foreach-Object { "`n`t{0} = '{1}'" -f @($_.Name, $_.Value) }) +
                            ("`n}`n") +
                                "Copy-Item @typeArgs -verbose"
                            ) | Write-Verbose
                            Copy-Item @typeArgs
                        }
                    }

                    foreach ($nugetConfigItem in ($nugetConfig | Where-Object { $_.addType } )) {
                        foreach ($typePath in $nugetConfigItem.addType) {
                            $typeArgs = @{
                                DependencyFolder = (Split-Path -Parent -Path $nugetConfigItem.Destination)
                                NugetPackageName = $nugetConfigItem.id
                                PathToDll        = $typePath
                            }
                            & "$($Context.libraryPath)\Add-TypeFromNugetPackage.ps1" @typeArgs
                        }
                    }

                    foreach ($nugetConfigItem in ($nugetConfig | Where-Object { $_.importModule } )) {
                        foreach ($importModulePath in $nugetConfigItem.importModule) {
                            $typeArgs = @{
                                DependencyFolder = (Split-Path -Parent -Path $nugetConfigItem.Destination)
                                NugetPackageName = $nugetConfigItem.id
                                PathToPsm1       = $importModulePath
                            }
                            & "$($Context.libraryPath)\Import-ModuleFromNugetPackage.ps1" @typeArgs
                        }
                    }
                }
            }
            Write-Verbose "DONE: Installing all Dependencies for $Path. Duration: $($overallElapsed.Elapsed.ToString())"
        } else {
            Install-DependencyFromName -Context $context -Path $Path -Destination $Destination -Force:$Force.IsPresent
        }
    } catch {
        throw
    }
}
